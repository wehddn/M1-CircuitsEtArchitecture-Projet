#+TITLE: Circuits et architecture 2022/2023 -- Journal du cours
#+AUTHOR: Adrien Guatto
#+EMAIL: guatto@irif.org
#+LANGUAGE: fr
#+OPTIONS: ^:nil p:nil tex:t
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{a4wide}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \hypersetup{colorlinks = true}
#+LATEX_HEADER: \usepackage[french]{babel}
# (org-latex-export-to-pdf)
* Cours 1 <2022-09-16>
** Introduction
   Bienvenue dans le cours _Circuits et architecture_ !

   Les ann√©es pr√©c√©dentes, vous avez utilis√© des outils et concepts comme des
   bo√Ætes noires, sans forc√©ment comprendre leur fonctionnement interne. Par
   exemple, vous avez programm√© en C sans que l'on vous explique comment ce
   langage √©tait impl√©ment√© exactement. Durant vos deux prochaines ann√©es
   d'√©tudes, vous allez ouvrir ces bo√Ætes noires, et d√©couvrir comment elles
   fonctionnent sous le capot.

   En l'occurence, l'objectif du cours _Circuit et architecture_ est d'expliquer
   le fonctionnement des machines √† calculer programmables appel√©es
   /ordinateurs/. Le cours d√©bute des couches mat√©rielles tr√®s basses jusqu'√†
   remonter au niveau du langage C.
*** Supports et organisation
    Tous les documents (support, projet, feuilles de TD, etc.) sont disponibles
    sur le d√©p√¥t Git du module.

    https://gaufre.informatique.univ-paris-diderot.fr/aguatto/architecture-m1-22-23

    Il contient notamment un r√©sum√© (syllabus) du module, qui r√©sume toutes les
    informations pratiques du cours et propose un plan des sujets trait√©s s√©ance
    par s√©ance. Prenons le temps de le lire ensemble.

    Comme √©crit dans le syllabus, l'enseignement reprend pour l'essentiel le
    contenu du cours dispens√© par M. Carton les ann√©es pr√©c√©dentes. Il s'appuie
    en particulier sur le support de cours r√©dig√© par ce dernier :

    https://www.irif.fr/~carton/Enseignement/Architecture/archi.pdf

    (Il existe aussi au format HTML, voir la page de M. Carton.)

    Le d√©p√¥t Git du cours contient √©galement un journal (que vous √™tes en train
    de lire !) qui r√©sume succinctement les points trait√©s en cours chaque
    semaine. La notation ¬ßX.Y fera r√©f√©rence √† la section X des notes de
    M. Carton. Le journal sera plus d√©taill√© lorsque le cours s'√©loignera un peu
    des dites notes.

    *Attention* : la lecture des notes de M. Carton et du journal ne remplace
    pas la pr√©sence en cours. Les notes contiennent √† la fois plus et moins
    d'information que les cours magistraux. Elles sont l√† pour vous permettre de
    vous concentrer sur une prise de notes /active/, et en particulier vous
    √©vite d'avoir √† recopier les sch√©mas dessin√©s au tableau.

    Autre remarque : le cours ne contient aucun concept vraiment difficile. En
    revanche, on va manipuler beaucoup de /niveaux d'abstraction/ diff√©rents,
    des portes logiques jusqu'√† des questions de programmation syst√®me. La
    principale difficult√© est de comprendre l'articulation de ces niveaux, qui
    sera n√©cessaire pour r√©aliser le projet !
** Le cours
*** Historique g√©n√©ral (¬ß2.1)
    Une histoire des machines √† calculer, concept tr√®s ancien.

    D√®s le d√©but, le d√©veloppement des machines √† calculer est motiv√© par des
    besoins concrets, commerciaux et administratifs puis militaires (XX√®me).

    Les progr√®s th√©oriques (Boole, Turing, G√∂del, Church) sont parall√®les aux
    progr√®s pratiques mais ne les rencontrent que tardivement (1950+). En
    particulier, si les contributions th√©oriques d'Alan Turing sont immenses, et
    ses contributions pratiques grandes, on ne peut pas dire qu'il a invent√©
    l'ordinateur (= programmable) comme on l'entend parfois.

    Une histoire des processeurs passe n√©cessairement par une histoire des
    compagnies qui fabriquent les processeurs. L'architecture des ordinateurs
    est domin√©e par l'industrie et le domaine militaire (supercalculateurs).

    Une s√©lection biais√©e vers x86 de quelques microprocesseurs :

    |-------+----------+-----------+---------+---------+--------+------------|
    | Ann√©e |      Nom | Fabricant | Mot     | Freq.   | Trans. | Notes      |
    |-------+----------+-----------+---------+---------+--------+------------|
    |  1971 |     4004 | Intel     | 4 bits  | 108 KHz | 2,3K   | 1er Œº-proc |
    |  1972 |     8008 | Intel     | 8 bits  | 200 KHz | 3,5K   |            |
    |  1978 |     8086 | Intel     | 16 bits | 5 MHz   | 29K    | 1er x86    |
    |  1985 |    80386 | Intel     | 32 bits | 12 MHz  | 275K   | 1er x86-32 |
    |  1995 |  Pentium | Intel     | 32 bits | 60 MHz  | 3,1M   |            |
    |  2003 |  Opteron | AMD       | 64 bits | 1,4 GHz | 106M   | 1er x86-64 |
    |  2022 | M1 Ultra | Apple     | 64 bits | 3,2 GHz | 114G   | ARM, 20c   |
    |-------+----------+-----------+---------+---------+--------+------------|

    Beaucoup d'autres choses √† l'√©poque et depuis 2003 : essor puis d√©clin des
    architectures RISC ; r√©cemment essor de puissants concurrents √† x86-64 (ARM,
    Nvidia) ; nouveaux segments (mobiles) ; optimisation de la consommation
    √©nerg√©tique ; l'embarqu√© devient dominant en volume dans les ann√©es 1990
    (x86 y est inexistant).
*** Les portes logiques
    Apr√®s ces quelques √©l√©ments de contexte, rentrons dans le vif du sujet :
    construire un ordinateur num√©rique programmable. On va adopter une d√©marche
    ascendante (ou /bottom-up/) : on commence avec le niveau d'abstraction le
    plus bas, puis on remonte vers le logiciel.

    (√Ä nuancer : il y a presque toujours plus bas, √† moins de descendre √† une
    description quantique de la mati√®re subatomique. Ce ne sera √©videmment pas
    le propos du cours.)

    Il faut dej√† nous demander ce que veut dire "num√©rique". De quels nombres
    parle-t-on ? Vous connaissez d√©j√† diff√©rents syst√®mes de nombres.

    ‚Ñï ‚äÜ ‚Ñ§ ‚äÜ ‚Ñö ‚äÜ ‚Ñù ‚äÜ ‚ÑÇ (‚äÜ ... ?)

    Certains de ces ensembles sont de m√™me cardinal ("taille"), comme ‚Ñï, ‚Ñ§ ou
    ‚Ñö qui sont de m√™me cardinal strictement plus petit que celui de ‚Ñù et ‚ÑÇ. On
    va commencer avec un ensemble de "nombres" de cardinal fini : les
    bool√©ens.

    Ce sera notre niveau d'abstraction de base : la num√©ration bool√©enne, b√¢tie
    sur l'ensemble ùîπ = { 0, 1 }. C'est un syst√®me de nombre un peu √©trange, mais
    qui a l'avantage de pouvoir aussi √™tre vu sous un angle logique.

    En effet, les op√©rateurs logique NOT, AND, OR, XOR, NOR, NAND peuvent aussi
    √™tre compris comme des op√©rateurs arithm√©tiques. Pour cette raison, on note
    ¬∑ pour AND et + pour OR. L'analogie avec l'arithm√©tique est moins claire
    pour NOT et XOR, et les notations sont donc moins fix√©es : pour NOT on
    utilisera le symbole ¬¨ ou la barre de surlignement, pour XOR le symbole ‚äï.

    Ces op√©rateurs sont des fonctions /bool√©ennes/, de la forme ùîπ‚Åø ‚Üí ùîπ.

    On rappelle qu'une fonction math√©matique f : X ‚Üí Y est d√©fini comme un
    ensemble de couples (a, b) ‚àà X √ó Y tel que pour tout a ‚àà X, il existe un
    unique b ‚àà Y tel que (a, b) ‚àà f. Si X et Y sont infinis, f l'est aussi, mais
    dans le cas des fonctions bool√©ennes X = ùîπ‚Åø qui est fini (de cardinal 2‚Åø) et
    Y = ùîπ (de cardinal 2) √©galement, donc on peut repr√©senter la fonction comme
    l'ensemble fini des couples entr√©es/sortie. C'est sa /table de v√©rit√©/.

    *Q* : donner les tables de v√©rit√© de NOT, AND, OR, XOR, NOR, NAND.

    (On peut remarquer que comme 1 + 1 = 1, si on souhaite voir les bool√©ens
    comme des nombres, on peut √©ventuellement penser √† "0" comme d√©nombrant
    "z√©ro √©l√©ments" et √† "1" comme d√©nombrant "beaucoup d'√©l√©ments".)

    Il est facile de v√©rifier que les op√©rateurs v√©rifient certaines lois
    alg√©briques (d√©couvertes par MM. Boole et de Morgan) : la n√©gation est
    involutive, le NOT distribue et transforme AND/OR en OR/AND, etc, AND et OR
    sont idempotents, etc.

    Il est clair que certaines de ces portes peuvent √™tre exprim√©es √† partir des
    autres. Litt√©ralement, on a NAND = NOT AND, NOR = NOT OR. Et les autres ?

    *Q* : comment exprimer XOR √† partir de NOT, AND, OR ?

    *R* : XOR(a, b) = (a OR b) AND NOT (A AND B) = (a + b) ¬∑ ¬¨ab = a

    *Q* : connaissez-vous un autre op√©rateur logique que ceux de la liste ?

    *A* : l'implication a ‚áí b = OR(NOT(A), B).

    Ces op√©rateurs bool√©ens peuvent √©galement √™tre vu comme des portes dans
    circuits o√π chaque fil transporte un bit. Ces circuits sont orient√©s, au
    sens o√π les fils transportent les bits dans une direction bien d√©finie.
    On peut voir les lois bool√©ennes comme des transformations de circuits.
    Voir les notes pour les notations, que vous connaissez s√ªrement d√©j√†.

    *Q* : montrer que NAND est un op√©rateur /universel/, capable d'exprimer tous
    les autres.

    *A* : NOT(a) = NAND(a, a), OR(a, b) = NAND(NOT(a), NOT(b)), AND s'exprime
    avec NOT et OR par de Morgan, XOR et NOR s'expriment en fonction de NOT, OR
    et AND.

    *Q*, √† faire chez vous : m√™me question pour le NOR.

    On a donc notre jeu de portes logiques √©l√©mentaires, qui (si on le souhaite)
    peut √™tre r√©duit au NOR ou bien au NAND. Mais quid des fonctions bool√©ennes
    en g√©n√©ral ? √âtant donn√©e une fonction / table de v√©rit√© quelconque, peut-on
    l'exprimer avec les portes pr√©c√©dentes ? La r√©ponse est oui. Voyons une
    m√©thode tr√®s simple, en commen√ßant par poser le probl√®me.

    Soit f : ùîπ‚Åø ‚Üí ùîπ.

    On veut coder cette fonction par une formule bool√©enne sur n variables x‚ÇÅ,
    ..., x‚Çô telle que, pour tout (a‚ÇÅ, ..., a‚Çô) ‚àà ùîπ‚Åø, la valeur de v√©rit√© de la
    formule o√π l'on a remplac√© x·µ¢ par a·µ¢ est √©gale √† f(a‚ÇÅ, ..., a‚Çô).

    Consid√©rons l'ensemble dom(f) ‚äÜ ùîπ‚Åø des n-uplets de bits a tel que f(a)
    = 1. Chaque n-uplet (a‚ÇÅ, ..., a‚Çô) peut √™tre d√©crit par une conjonction de n
    /atomes/, o√π un atome est une variable propositionnelle ou sa n√©gation. Le
    i-√®me atome est x·µ¢ si a·µ¢ = 1, ¬¨x·µ¢ si a·µ¢ = 0.  La formule obtenue en prenant
    la disjonction de toutes ces conjonctions a bien la propri√©t√© recherch√©e.

    Donc toute fonction bool√©enne s'√©crit comme une disjonction de conjonction
    d'atomes, i.e., en /forme normale disjonctive/ (FND). De plus, cette forme
    normale fournit une caract√©risation unique (f = g ssi FND(f) = FND(g)), pour
    un ordre d'√©num√©ration des entr√©es fix√©.

    *Attention* : la m√©thode d√©crite n'est pas une bonne m√©thode en pratique.
    L'expression est √©norme en g√©n√©ral, par exemple si on donne la fonction
    constante 1, on a une disjonction de 2‚Åø conjonctions, chacune de celle-ci
    comprenant n atomes. On verra des m√©thodes plus efficaces en TD, comme celle
    des tableaux de Karnaugh.

    La semaine prochaine, on verra comment r√©aliser physiquement les portes
    logiques en termes de transistors.
* Cours 2 <2022-09-23>
** Des transistors aux portes logiques (¬ß4)
*** Introduction
    C'est √† partir des portes logiques et fonctions bool√©ennes qu'on va
    construire le reste de l'informatique. Toutefois, les portes logiques sont
    des objets id√©aux qu'il va falloir r√©aliser physiquement pour s'en servir.
    Il va donc falloir parler un peu de physique et d'√©lectronique.

    L'id√©e est d'expliquer le fonctionnement du /transistor/, brique de base
    des circuits int√©gr√©s (form√©s de millions voire milliards d'entre eux
    !). Comme la physique-chimie d√©passe largement le cadre du cours, on va en
    donner une vision simplifi√©e et toujours tr√®s id√©alis√©e.
*** Semi-conducteurs, diodes et transistors
    (Les notes de cours contiennent beaucoup plus de d√©tails sur les aspects
    physiques et chimiques de cette partie du cours, et Wikip√©dia encore plus.)

    Un semi-conducteur est un mat√©riau dont la conductivit√© √©lectrique est
    situ√©e entre celle des isolants et celle des m√©taux. On peut le traiter
    chimiquement (/dopage/) pour modifier ses propri√©t√©s, et obtenir un
    semi-conducteur de type /n/, qui a des √©lectrons en trop, ou un
    semi-conducteur de type /p/, qui a des √©lectrons manquants, des
    "trous".

    En branchant un semi-conducteur p et un n, on obtient une diode, qui ne
    laisse passer le courant que dans un seul sens. En appliquant une tension √†
    l'anode et √† la cathode d'une diode, on peut la rendre conductrice ou
    non-conductrice. Cela rend la diode contr√¥lable par un signal ext√©rieur.

    Les transistors g√©n√©ralisent le fonctionnement de la diode. Ils sont eux
    aussi de deux types, /p/ et /n/. Les deux types de transistors ont trois
    pates, nomm√©es "grille", "source" et "drain". Leur comportement, pour
    ce qui nous int√©resse, est simplement celui d'un interrupteur, et on peut en
    donner une description abstraite.

    Dans un transistor de type /n/, lorsque la grille re√ßoit une tension de
    2,9V, l'interrupteur est ferm√© et source et drains sont connect√©s (source =
    drain, le transistor agit comme un fil). Si la grille ne re√ßoit pas de
    tension (0V), l'interrupteur est ouvert et il n'y a aucun lien entre source
    et drain. Les transistors /p/ agissent de fa√ßon sym√©trique, connectant
    source et drain lorsque la tension de la grille est 0V, et la fermant √† 0V.

    (Le comportement compl√©mentaire des transistors /n/ et /p/ explique le nom
    donn√© aux circuits qui en sont compos√©s : /Complementary Metal-Oxyde
    Semiconductors/, ou CMOS.)

    On peut donc comprendre le comportement des transistors de fa√ßon purement
    logique. La tension 2,9V correspond au bool√©en 1, et 0V au bool√©en 0. Le
    transistor /n/ peut √™tre d√©crit par la formule

      grille ‚áí (source = drain)

    et le transistor /p/ par la formule

      ¬¨grille ‚áí (source = drain).

     o√π "source = drain" est OR(AND(drain, source), AND(¬¨drain,¬¨source)).).

    On peut donc donner un sens purement logique, extra-physique, aux circuits
    compos√©s de transistors. Toutefois, attention : ces circuits, contrairement
    √† ceux de la section pr√©c√©dents, ne sont *pas* orient√©s. Il n'y a pas
    d'entr√©e et de sorties bien d√©finies √† ce niveau, le courant se propageant
    dans toutes les directions simultan√©ment. Du point de vue logique, notre
    circuit correspond √† une *contrainte* sur les valeurs possibles sur les
    fils, contrainte qui peut avoir 0, 1, ou plusieurs solutions.

    On peut donc les comprendre comme des circuits o√π chaque fil transporte un
    /ensemble/ de bits, c'est-√†-dire un sous-ensemble de ùîπ. Ces sous-ensembles
    sont faciles √† √©numerer : ‚àÖ, {0}, {1} et {0,1}. Les cas {0} et {1}
    correspondent au sous-cas des circuits d√©terministes.

    Supposons qu'un fil A transporte le sous-ensemble V, et un fil B transporte
    le sous-ensemble W. Que se passe-t-il lorsqu'on connecte A et B ? On force
    les valeurs transport√©es par A et B √† √™tre les m√™mes, et donc les valeurs
    transport√©es par A et B √† √™tre √† la fois dans V et W. Autrement dit, les
    valeurs transmises sont celles qui appartiennent √† V ‚à© W.

    Que se passe-t-il par exemple, si l'on connecte par un fil le g√©n√©rateur √†
    la terre ?  Les valeurs qui circulent sont dans {0} ‚à© {1} = ‚àÖ, ce qui
    correspond logiquement √† un circuit qui n'a pas de solution et, d'un point
    de vue plus pragmatique, √† un court-circuit.
*** Les portes logiques (¬ß4.5)
    Voir les notes.
** Repr√©sentation des types de donn√©es scalaires (¬ß3)
   Maintenant qu'on a quelque id√©e de comment manipuler des bits individuels, il
   est temps de passer √† la repr√©sentation des types de donn√©es scalaires, comme
   les nombres positifs ou relatifs, les r√©els, les caract√®res.

   (N.B. : ce sujet est plac√© avant celui des portes logiques et transistors
   dans les notes de cours).
*** Nombres entiers
    Supposons qu'on souhaite repr√©senter les entiers par $k$ bits num√©rot√©s
    $b_{k-1} \dots b_0$.

    Il existe diff√©rents codages qui se valent en th√©orie mais pas en
    pratique. Pour chaque codage $X$, on d√©finit une
    fonction $\mathit{decode}_X$.
**** Entiers naturels (positifs)
     Sur $k$ bits, on repr√©sente $2^k$ valeurs, soit l'intervalle $[0, 2^k-1]$,
     en utilisant la repr√©sentation en base 2 habituelle.

     \[
       \mathit{decode}_{\mathit{unsigned}}(b_{k-1} \dots b_0)
       =
       \sum_{i = 0}^{k - 1} b_i 2^i
     \]

     Cette repr√©sentation est dite *non-sign√©e* (/unsigned/ en anglais), par
     opposition aux repr√©sentations des entiers relatifs qui vont souvent
     utiliser un bit de signe.
**** Entiers relatifs
     On a le choix de plusieurs repr√©sentations.
***** Magnitude sign√©e
      Le bit de poids fort sert √† indiquer le signe du nombre, le reste des bits
      code un entier positif.

      \[
        \mathit{decode}_{\mathit{signedmagnitude}}(b_{k-1} \dots b_0)
        = -1^{b_{k-1}} \sum_{i = 0}^{k - 2} b_i 2^i
      \]

      Probl√®mes : redondant (0 est encod√© par $00\dots0$ et $10\dots0$),
      difficile d'impl√©menter les op√©rations arithm√©tiques.
***** Repr√©sentation biais√©e
      On compte de 1 en 1 √† partir de -2·µè‚Åª¬π.

     \[
       \mathit{decode}_{\mathit{biased}}(b_{k-1} \dots b_0)
       =
       -2^{k-1} + \sum_{i = 0}^{k - 1} b_i 2^i
     \]
***** Compl√©ment √† 2
      C'est la repr√©sentation utilis√©e en pratique, assez ing√©nieuse.

      L'id√©e est de conserver la formule du cas positif, mais d'inverser le
      signe du bit de poids fort.

      \[
        \mathit{decode}_{twoscomplement}(b_{k-1} \dots b_0)
        = -b_{k - 1} 2^{k-1} + \sum_{i = 0}^{k - 2} b_i 2^i
      \]

      On va voir que cette repr√©sentation jouit de bonnes propri√©t√©s, ce qui
      facilite l'impl√©mentation des op√©rations arithm√©tiques.

      Par exemple, que se passe-t-il si on additionne la repr√©sentation d'un
      nombre et celle de son oppos√© /sans se soucier du bit de signe/ (comme on
      le ferait pour des entiers non-sign√©s) ?
***** R√©capitulatif
      |------------------------+----------------+----------------|
      | Nom                    | Min repr√©sent√© | Max repr√©sent√© |
      |------------------------+----------------+----------------|
      | Non sign√©e             | $0$            | $2^k-1$        |
      | Magnitude sign√©e       | $-2^{k-1}+1$   | $2^{k-1}-1$    |
      | Repr√©sentation biais√©e | $-2^{k-1}$     | $2^{k-1}-1$    |
      | Compl√©ment √† 2         | $-2^{k-1}$     | $2^{k-1}-1$    |
      |------------------------+----------------+----------------|

      Exemple de codage pour k = 3.

     |------+---------+------------------+------------------------+----------------|
     | Bits | Naturel | Magnitude sign√©e | Repr√©sentation biais√©e | Compl√©ment √† 2 |
     |------+---------+------------------+------------------------+----------------|
     |  000 |       0 |                0 |                     -4 |              0 |
     |  001 |       1 |                1 |                     -3 |              1 |
     |  010 |       2 |                2 |                     -2 |              2 |
     |  011 |       3 |                3 |                     -1 |              3 |
     |  100 |       4 |               -0 |                      0 |             -4 |
     |  101 |       5 |               -1 |                      1 |             -3 |
     |  110 |       6 |               -2 |                      2 |             -2 |
     |  111 |       7 |               -3 |                      3 |             -1 |
     |------+---------+------------------+------------------------+----------------|
**** Op√©rations arithm√©tiques
***** Somme d'entiers non sign√©s
      L'algorithme est le m√™me que celui qu'on a appris √† l'√©cole primaire, √†
      ceci pr√®s que les chiffres sont dans $[0, 1]$ plut√¥t que $[0, 9]$.
***** Oppos√© en compl√©ment √† deux
     Quel entier la n√©gation bit-√†-bit de $b_{k-1} \dots b_0$ code-t-elle,
     lorsqu'on utilise la repr√©sentation en compl√©ment √† deux ?

     \begin{align*}
       \mathit{decode}_{twoscomplement}(\overline{b_{k-1} \dots b_0})
       & = -\overline{b_{k - 1}} 2^{k-1} + \sum_{i = 0}^{k - 2} \overline{b_i} 2^i
       \\
       & = -(1 - b_{k - 1}) 2^{k-1} + \sum_{i = 0}^{k - 2} (1 - b_i) 2^i
       \\
       & = -2^{k-1} + b_{k - 1} 2^{k-1} + \left(\sum_{i = 0}^{k - 2} 2^i\right) - \left(\sum_{i = 0}^{k-2} b_i 2^i\right)
       \\
       & = -2^{k-1} + 2^{k-1}-1 + b_{k - 1} 2^{k-1} - \left(\sum_{i = 0}^{k-2} b_i 2^i\right)
       \\
       & = -\mathit{decode}_{twoscomplement}(b_{k-1} \dots b_0) - 1
     \end{align*}

     On en d√©duit imm√©diatement un algorithme commode pour le calcul de l'oppos√©
     sur la repr√©sentation en compl√©ment √† deux.
***** Somme d'entiers sign√©s
      Int√©r√™t du compl√©ment √† deux : la somme est calcul√©e sans traiter
      sp√©cifiquement le bit de signe, √† part pour ce qui est de la d√©tection de
      d√©passement de capacit√©. Voir le tableau des notes en ¬ß3.1.4.3.3 pour
      l'exemple de k = 3.

      *Observation* : le plus petit entier qui peut r√©sulter de l'addition de
      $[-2^{k-1}, 0]$ avec un entier dans $[0, 2^{k-1}-1]$ est $-2^{k-1}$,
      tandis que le plus grand est $2^{k-1}-1$. Donc, aucun d√©passement de
      capacit√© ne peut r√©sulter de l'addition d'un positif et d'un n√©gatif.

      Supposons qu'on calcule la somme des bits $(a_i)_{0 \le i < n}$ et
      $(b_j)_{0 \le j < n}$ pour obtenir les bits r√©sultat $(s_i)_{0 \le i < n}$
      et les bits de retenue $(c_i)_{0 \le i < n + 1}$.

      |-----------+-----------+-----------+-----------+-------+---------------|
      | $a_{k-1}$ | $b_{k-1}$ | $c_{k-1}$ | $s_{k-1}$ | $c_k$ | d√©passement ? |
      |-----------+-----------+-----------+-----------+-------+---------------|
      |         0 |         0 |         0 |         0 |     0 | non           |
      |         0 |         0 |         1 |         1 |     0 | oui           |
      |-----------+-----------+-----------+-----------+-------+---------------|
      |         0 |         1 |         0 |         1 |     0 | non           |
      |         0 |         1 |         1 |         0 |     1 | non           |
      |-----------+-----------+-----------+-----------+-------+---------------|
      |         1 |         1 |         0 |         0 |     1 | oui           |
      |         1 |         1 |         1 |         1 |     1 | non           |
      |-----------+-----------+-----------+-----------+-------+---------------|

      On constate que les cas de d√©passement sont exactements ceux o√π $c_k \ne
      c_{k-1}$, c'est-√†-dire o√π~$c_k \oplus c_{k+1}$ est vrai.
*** Nombres r√©els et virgule flottante (¬ß3.3)
    (/Cette partie n'a pas √©t√© trait√©e en cours mais abord√©e en travaux
    dirig√©s/.)

    Par nature, le probl√®me du codage des nombres r√©els dans un nombre fini de
    bits est plus difficile que celui des nombres entiers, puisqu'il y en a
    strictement plus. Pire, contrairement au cas des entiers, on ne pas esp√©rer
    d√©crire exactement un intervalle de r√©els dans un nombre fini de bits. Se
    poseront donc des questions √©pineuses de calcul d'arrondi.

    Un bon compromis entre performance et pr√©cision est fourni par les formats
    de la norme IEEE-754. On dit que ce format utilise la /virgule flottante/
    parce que la valeur de l'exposant, qui d√©termine le nombre de chiffre, n'est
    pas fix√©e. (Il existe d'autres formats dits √† /virgule fixe/ o√π le nombre de
    chiffres apr√®s la virgule est le m√™me pour tous les nombres repr√©sent√©s, ce
    qui m√®ne en g√©n√©ral √† des op√©rations moins pr√©cises mais plus simples √†
    impl√©menter et donc populaires dans le contexte des syst√®mes embarqu√©s.)

    La repr√©sentation utilise trois champs de taille distincte : un champ
    /signe/, un champ /exposant/, un champ /mantisse/ (partie fractionnaire).
    La taillle de ces champs d√©pend du format de pr√©cision adopt√©. La norme
    IEEE-754 en propose trois : pr√©cision /simple/, /double/ ou
    /√©tendue/. Ci-dessous, la taille des champs pour la pr√©cision simple, qui
    correspond au type /float/ en Java ou en C.

    |-----------+-----------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------|
    | $b_{31}$  | $b_{30} b_{29} b_{28} b_{27} b_{26} b_{27} b_{24} b_{23}$ | $b_{22} b_{21} b_{20} b_{19} b_{18} b_{17} b_{16} b_{15} b_{14} b_{13} b_{12} b_{11} b_{10} b_{9} b_{8} b_{7} b_{6} b_{5} b_{4} b_{3} b_{2} b_{1} b_{0}$ |
    |-----------+-----------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------|
    | 1 bit     | 8 bits                                                    | 23 bits                                                                                                                                                  |
    |-----------+-----------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------|
    | signe $s$ | exposant $e$                                              | mantisse $m$                                                                                                                                             |
    |-----------+-----------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------|
    | $s$       | $e_{7} e_{6} e_{5} e_{4} e_{3} e_{2} e_{1} e_{0}$         | $m_{22} m_{21} m_{20} m_{19} m_{18} m_{17} m_{16} m_{15} m_{14} m_{13} m_{12} m_{11} m_{10} m_{9} m_{8} m_{7} m_{6} m_{5} m_{4} m_{3} m_{2} m_{1} m_{0}$ |
    |           |                                                           |                                                                                                                                                          |
    |-----------+-----------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------|

    \[
       \mathit{decode}_{ieee754single}(\langle s, e, m \rangle) =
       (-1)^s \cdot (1,m) \cdot 2^{e-127}
       \mbox{ o√π } 1,m = 1 + \sum_{i = 1}^{23} m_{23-i} 2^{-i}
       \mbox{ et } e \not\in \{ 0, 255 \}
    \]

    Les cas o√π l'exposant est $0$ ou $255$ correspondent √† des valeurs
    sp√©ciales, par exemple des nombres tr√®s petits appel√©s /sous-normaux/, ou
    encore $\infty$, ou encore la valeur ind√©finie /Not-a-Number/ (/NaN/) qui
    sert √† propager des erreurs.

    Les d√©tails fins du format IEEE-754 d√©passent le cadre du cours. Si vous
    √™tes int√©ress√©, l'article
    [[https://www.itu.dk/~sestoft/bachelor/IEEE754_article.pdf][_What Every
    Computer Scientist Should Know About Floating-Point Arithmetic_]] de David
    Goldberg fournit une introduction raisonnablement d√©taill√©e. La page
    [[https://en.wikipedia.org/wiki/IEEE_754][IEEE-754]] de la Wikip√©dia
    anglophone est aussi de bonne qualit√©.
*** Interlude : repr√©sentations num√©riques de taille variable
    Pour finir, une remarque importante : les repr√©sentations num√©riques
    d√©crites pr√©c√©demment sont de taille born√©e, ce qui est un pr√©requis pour
    une impl√©mentation en mat√©riel. En cons√©quence, elles ne peuvent d√©crire
    qu'un sous-ensemble fini de ‚Ñï ou ‚Ñù.

    En logiciel, on peut repr√©senter une portion de ‚Ñï ou ‚Ñù limit√©e uniquement
    par la quantit√© de m√©moire disponible. Par exemple, la biblioth√®que
    [[https://gmplib.org][GNU MP]] propose des vrais entiers math√©matiques de
    taille arbitraire, et la biblioth√®que [[https://www.mpfr.org][GNU MPFR]]
    fait de m√™me pour les nombres √† virgule flottante.
*** Caract√®res
**** ASCII
     Le jeu de caract√®re ASCII (/American Standard Code for Information
     Interchange/) encode 128 caract√®res sur 7 bits. Il a √©t√© et reste tr√®s
     r√©pandu, mais ses origines am√©ricaines le rendent inadapt√© √† l'informatique
     moderne : il se restreint √† l'alphabet latin, sans accents.
**** Unicode
     Le consortium Unicode propose une norme capable de g√©rer un tr√®s grand
     nombre de caract√®res (149186 en septembre 2022). La norme divise le travail
     de codage en deux aspects :

     1. chaque caract√®re se voit assign√© un entier unique compris entre 0 et
        0x10FFFF (soit un maximum th√©orique de 1,114M caract√®res), son /point de
        code/, ind√©pendamment de tout codage concret ;

     2. un codage concret des entiers encodant chaque caract√®re, qui peut √™tre
        plus ou moins complexe √† coder/d√©coder.

     Pour ce qui est du premier aspect, pr√©cisons qu'Unicode comprend beaucoup
     plus que des caract√®res issus d'alphabets, puisqu'il contient aussi les
     diacritiques (accents, tr√©mas, c√©dilles, etc.), les caract√®res
     math√©matiques, les emojis, etc.

     Pour ce qui est du second, citons au moins deux codages int√©ressants.

     Le codage *UTF-32* code tout caract√®re sur 32 bits. Il s'agit donc d'un
     codage co√ªteux mais qui a l'avantage de la simplicit√© et rend certaines
     op√©rations efficaces, comme par exemple le calcul de la longueur d'une
     cha√Æne (si l'on ignore le probl√®me de la normalisation, voir plus bas).

     Le codage *UTF-8* est un codage de longueur variable. Il est compatible
     avec ASCII : les caract√®res codables en ASCII sont cod√©s sur 1 octet en
     UTF-8 et avec la m√™me repr√©sentation. Les autres caract√®res sont cod√©s sur
     2 √† 4 octets.

     La norme Unicode est complexe. Par exemple, un m√™me "caract√®re" (au sens
     humain) peut √™tre r√©alis√© par la combinaison de plusieurs points de code.
     Par exemple, le caract√®re ~√á~ dispose d'un point de code d√©di√© (0xC7), mais
     peut aussi √™tre r√©alis√© par le point de code ~COMBINING CEDILLA~ (0x327)
     pr√©c√©d√© du point de code de ~C~ (0x43). Petite illustration en Python
     ci-dessous :

     #+BEGIN_SRC python
>>> "\u00C7"
√á
>>> "\u0043\u0327"
CÃß
>>> "\u0043"
C
>>> "\u0327"
 Ãß
     #+END_SRC

     Ainsi, les s√©quences de points de code doivent √™tre consid√©r√©es modulo une
     relation d'√©quivalence qui exprime que ~C~ suivi de ~COMBINING CEDILLA~ ne
     doit pas √™tre distingu√© de ~√á~. Pour cette raison, la norme Unicode d√©crit
     un algorithme de normalisation qui calcule pour toute s√©quence de points de
     code une autre s√©quence, sa /forme normale/. Cet algorithme v√©rifie des
     propri√©t√©s tr√®s classiques ; en √©crivant $\equiv$ pour l'√©quivalence et
     $\mathit{nf}$ pour l'algorithme de normalisation, on a que

     1. toute s√©quence est √©quivalente √† sa forme normale ($s \equiv
        \mathit{nf}(s)$),

     2. deux s√©quences √©quivalentes ont la m√™me forme normale ($s_1 \equiv _2
        \Rightarrow \mathit{nf}(s_1) = \mathit{nf}(s_2)$),

     3. la normalisation est idempotente, une forme normale est sa propre forme
        normale ($\mathit{nf}(\mathit{nf}(s)) = \mathit{nf}(s)$).

     Le fragment de code Python montre un exemple de normalisation unicode. On
     doit sp√©cifier la notion exacte de forme normale √† utiliser, car la norme
     en propose plusieurs (ici /Normal Form Canonical Composition/ ou /NFC/, qui
     recompose les combinaisons de caract√®re).

     #+BEGIN_SRC python
>>> len("\u0043\u0327")
2
>>> from unicodedata import normalize
>>> normalize("NFC", "\u0043\u0327")
'√á'
>>> len(normalize("NFC", "\u0043\u0327"))
1
     #+END_SRC
