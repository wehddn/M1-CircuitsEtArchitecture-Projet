#+TITLE: Circuits et architecture 2022/2023 -- Journal du cours
#+AUTHOR: Adrien Guatto
#+EMAIL: guatto@irif.org
#+LANGUAGE: fr
#+OPTIONS: ^:nil p:nil
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,11pt]
#+LATEX_HEADER: \usepackage{a4wide}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \hypersetup{colorlinks = true}
#+LATEX_HEADER: \usepackage[french]{babel}
# (org-latex-export-to-pdf)
* Cours 1 <2022-09-16>
** Introduction
   Bienvenue dans le cours _Circuits et architecture_ !

   Les ann√©es pr√©c√©dentes, vous avez utilis√© des outils et concepts comme des
   bo√Ætes noires, sans forc√©ment comprendre leur fonctionnement interne. Par
   exemple, vous avez programm√© en C sans que l'on vous explique comment ce
   langage √©tait impl√©ment√© exactement. Durant vos deux prochaines ann√©es
   d'√©tudes, vous allez ouvrir ces bo√Ætes noires, et d√©couvrir comment elles
   fonctionnent sous le capot.

   En l'occurence, l'objectif du cours _Circuit et architecture_ est d'expliquer
   le fonctionnement des machines √† calculer programmables appel√©es
   /ordinateurs/. Le cours d√©bute des couches mat√©rielles tr√®s basses jusqu'√†
   remonter au niveau du langage C.
*** Supports et organisation
    Tous les documents (support, projet, feuilles de TD, etc.) sont disponibles
    sur le d√©p√¥t Git du module.

    https://gaufre.informatique.univ-paris-diderot.fr/aguatto/architecture-m1-22-23

    Il contient notamment un r√©sum√© (syllabus) du module, qui r√©sume toutes les
    informations pratiques du cours et propose un plan des sujets trait√©s s√©ance
    par s√©ance. Prenons le temps de le lire ensemble.

    Comme √©crit dans le syllabus, l'enseignement reprend pour l'essentiel le
    contenu du cours dispens√© par M. Carton les ann√©es pr√©c√©dentes. Il s'appuie
    en particulier sur le support de cours r√©dig√© par ce dernier :

    https://www.irif.fr/~carton/Enseignement/Architecture/archi.pdf

    (Il existe aussi au format HTML, voir la page de M. Carton.)

    Le d√©p√¥t Git du cours contient √©galement un journal (que vous √™tes en train
    de lire !) qui r√©sume succinctement les points trait√©s en cours chaque
    semaine. La notation ¬ßX.Y fera r√©f√©rence √† la section X des notes de
    M. Carton. Le journal sera plus d√©taill√© lorsque le cours s'√©loignera un peu
    des dites notes.

    *Attention* : la lecture des notes de M. Carton et du journal ne remplace
    pas la pr√©sence en cours. Les notes contiennent √† la fois plus et moins
    d'information que les cours magistraux. Elles sont l√† pour vous permettre de
    vous concentrer sur une prise de notes /active/, et en particulier vous
    √©vite d'avoir √† recopier les sch√©mas dessin√©s au tableau.

    Autre remarque : le cours ne contient aucun concept vraiment difficile. En
    revanche, on va manipuler beaucoup de /niveaux d'abstraction/ diff√©rents,
    des portes logiques jusqu'√† des questions de programmation syst√®me. La
    principale difficult√© est de comprendre l'articulation de ces niveaux, qui
    sera n√©cessaire pour r√©aliser le projet !
** Le cours
*** Historique g√©n√©ral (¬ß2.1)
    Une histoire des machines √† calculer, concept tr√®s ancien.

    D√®s le d√©but, le d√©veloppement des machines √† calculer est motiv√© par des
    besoins concrets, commerciaux et administratifs puis militaires (XX√®me).

    Les progr√®s th√©oriques (Boole, Turing, G√∂del, Church) sont parall√®les aux
    progr√®s pratiques mais ne les rencontrent que tardivement (1950+). En
    particulier, si les contributions th√©oriques d'Alan Turing sont immenses, et
    ses contributions pratiques grandes, on ne peut pas dire qu'il a invent√©
    l'ordinateur (= programmable) comme on l'entend parfois.

    Une histoire des processeurs passe n√©cessairement par une histoire des
    compagnies qui fabriquent les processeurs. L'architecture des ordinateurs
    est domin√©e par l'industrie et le domaine militaire (supercalculateurs).

    Une s√©lection biais√©e vers x86 de quelques microprocesseurs :

    |-------+----------+-----------+---------+---------+--------+------------|
    | Ann√©e |      Nom | Fabricant | Mot     | Freq.   | Trans. | Notes      |
    |-------+----------+-----------+---------+---------+--------+------------|
    |  1971 |     4004 | Intel     | 4 bits  | 108 KHz | 2,3K   | 1er Œº-proc |
    |  1972 |     8008 | Intel     | 8 bits  | 200 KHz | 3,5K   |            |
    |  1978 |     8086 | Intel     | 16 bits | 5 MHz   | 29K    | 1er x86    |
    |  1985 |    80386 | Intel     | 32 bits | 12 MHz  | 275K   | 1er x86-32 |
    |  1995 |  Pentium | Intel     | 32 bits | 60 MHz  | 3,1M   |            |
    |  2003 |  Opteron | AMD       | 64 bits | 1,4 GHz | 106M   | 1er x86-64 |
    |  2022 | M1 Ultra | Apple     | 64 bits | 3,2 GHz | 114G   | ARM, 20c   |
    |-------+----------+-----------+---------+---------+--------+------------|

    Beaucoup d'autres choses √† l'√©poque et depuis 2003 : essor puis d√©clin des
    architectures RISC ; r√©cemment essor de puissants concurrents √† x86-64 (ARM,
    Nvidia) ; nouveaux segments (mobiles) ; optimisation de la consommation
    √©nerg√©tique ; l'embarqu√© devient dominant en volume dans les ann√©es 1990
    (x86 y est inexistant).
*** Les portes logiques
    Apr√®s ces quelques √©l√©ments de contexte, rentrons dans le vif du sujet :
    construire un ordinateur num√©rique programmable. On va adopter une d√©marche
    ascendante (ou /bottom-up/) : on commence avec le niveau d'abstraction le
    plus bas, puis on remonte vers le logiciel.

    (√Ä nuancer : il y a presque toujours plus bas, √† moins de descendre √† une
    description quantique de la mati√®re subatomique. Ce ne sera √©videmment pas
    le propos du cours.)

    Il faut dej√† nous demander ce que veut dire "num√©rique". De quels nombres
    parle-t-on ? Vous connaissez d√©j√† diff√©rents syst√®mes de nombres.

    ‚Ñï ‚äÜ ‚Ñ§ ‚äÜ ‚Ñö ‚äÜ ‚Ñù ‚äÜ ‚ÑÇ (‚äÜ ... ?)

    Certains de ces ensembles sont de m√™me cardinal ("taille"), comme ‚Ñï, ‚Ñ§ ou ‚Ñö
    qui sont de m√™me cardinal strictement plus petit que celui de ‚Ñù et ‚ÑÇ. On va
    commencer avec un ensemble de "nombres" de cardinal fini : les bool√©ens.

    Ce sera notre niveau d'abstraction de base : la num√©ration bool√©enne, b√¢tie
    sur l'ensemble ùîπ = { 0, 1 }. C'est un syst√®me de nombre un peu √©trange, mais
    qui a l'avantage de pouvoir aussi √™tre vu sous un angle logique.

    En effet, les op√©rateurs logique NOT, AND, OR, XOR, NOR, NAND peuvent aussi
    √™tre compris comme des op√©rateurs arithm√©tiques. Pour cette raison, on note
    ¬∑ pour AND et + pour OR. L'analogie avec l'arithm√©tique est moins claire
    pour NOT et XOR, et les notations sont donc moins fix√©es : pour NOT on
    utilisera le symbole ¬¨ ou la barre de surlignement, pour XOR le symbole ‚äï.

    Ces op√©rateurs sont des fonctions /bool√©ennes/, de la forme ùîπ‚Åø ‚Üí ùîπ.

    On rappelle qu'une fonction math√©matique f : X ‚Üí Y est d√©fini comme un
    ensemble de couples (a, b) ‚àà X √ó Y tel que pour tout a ‚àà X, il existe un
    unique b ‚àà Y tel que (a, b) ‚àà f. Si X et Y sont infinis, f l'est aussi, mais
    dans le cas des fonctions bool√©ennes X = ùîπ‚Åø qui est fini (de cardinal 2‚Åø) et
    Y = ùîπ (de cardinal 2) √©galement, donc on peut repr√©senter la fonction comme
    l'ensemble fini des couples entr√©es/sortie. C'est sa /table de v√©rit√©/.

    *Q* : donner les tables de v√©rit√© de NOT, AND, OR, XOR, NOR, NAND.

    (On peut remarquer que comme 1 + 1 = 1, si on souhaite voir les bool√©ens
    comme des nombres, on peut √©ventuellement penser √† "0" comme d√©nombrant
    "z√©ro √©l√©ments" et √† "1" comme d√©nombrant "beaucoup d'√©l√©ments".)

    Il est facile de v√©rifier que les op√©rateurs v√©rifient certaines lois
    alg√©briques (d√©couvertes par MM. Boole et de Morgan) : la n√©gation est
    involutive, le NOT distribue et transforme AND/OR en OR/AND, etc, AND et OR
    sont idempotents, etc.

    Il est clair que certaines de ces portes peuvent √™tre exprim√©es √† partir des
    autres. Litt√©ralement, on a NAND = NOT AND, NOR = NOT OR. Et les autres ?

    *Q* : comment exprimer XOR √† partir de NOT, AND, OR ?

    *R* : XOR(a, b) = (a OR b) AND NOT (A AND B) = (a + b) ¬∑ ¬¨ab = a

    *Q* : connaissez-vous un autre op√©rateur logique que ceux de la liste ?

    *A* : l'implication a ‚áí b = OR(NOT(A), B).

    Ces op√©rateurs bool√©ens peuvent √©galement √™tre vu comme des portes dans
    circuits o√π chaque fil transporte un bit. Ces circuits sont orient√©s, au
    sens o√π les fils transportent les bits dans une direction bien d√©finie.
    On peut voir les lois bool√©ennes comme des transformations de circuits.
    Voir les notes pour les notations, que vous connaissez s√ªrement d√©j√†.

    *Q* : montrer que NAND est un op√©rateur /universel/, capable d'exprimer tous
    les autres.

    *A* : NOT(a) = NAND(a, a), OR(a, b) = NAND(NOT(a), NOT(b)), AND s'exprime
    avec NOT et OR par de Morgan, XOR et NOR s'expriment en fonction de NOT, OR
    et AND.

    *Q*, √† faire chez vous : m√™me question pour le NOR.

    On a donc notre jeu de portes logiques √©l√©mentaires, qui (si on le souhaite)
    peut √™tre r√©duit au NOR ou bien au NAND. Mais quid des fonctions bool√©ennes
    en g√©n√©ral ? √âtant donn√©e une fonction / table de v√©rit√© quelconque, peut-on
    l'exprimer avec les portes pr√©c√©dentes ? La r√©ponse est oui. Voyons une
    m√©thode tr√®s simple, en commen√ßant par poser le probl√®me.

    Soit f : ùîπ‚Åø ‚Üí ùîπ.

    On veut coder cette fonction par une formule bool√©enne sur n variables x‚ÇÅ,
    ..., x‚Çô telle que, pour tout (a‚ÇÅ, ..., a‚Çô) ‚àà ùîπ‚Åø, la valeur de v√©rit√© de la
    formule o√π l'on a remplac√© x·µ¢ par a·µ¢ est √©gale √† f(a‚ÇÅ, ..., a‚Çô).

    Consid√©rons l'ensemble dom(f) ‚äÜ ùîπ‚Åø des n-uplets de bits a tel que f(a)
    = 1. Chaque n-uplet (a‚ÇÅ, ..., a‚Çô) peut √™tre d√©crit par une conjonction de n
    /atomes/, o√π un atome est une variable propositionnelle ou sa n√©gation. Le
    i-√®me atome est x·µ¢ si a·µ¢ = 1, ¬¨x·µ¢ si a·µ¢ = 0.  La formule obtenue en prenant
    la disjonction de toutes ces conjonctions a bien la propri√©t√© recherch√©e.

    Donc toute fonction bool√©enne s'√©crit comme une disjonction de conjonction
    d'atomes, i.e., en /forme normale disjonctive/ (FND). De plus, cette forme
    normale fournit une caract√©risation unique (f = g ssi FND(f) = FND(g)), pour
    un ordre d'√©num√©ration des entr√©es fix√©.

    *Attention* : la m√©thode d√©crite n'est pas une bonne m√©thode en pratique.
    L'expression est √©norme en g√©n√©ral, par exemple si on donne la fonction
    constante 1, on a une disjonction de 2‚Åø conjonctions, chacune de celle-ci
    comprenant n atomes. On verra des m√©thodes plus efficaces en TD, comme celle
    des tableaux de Karnaugh.

    La semaine prochaine, on verra comment r√©aliser physiquement les portes
    logiques en termes de transistors.
